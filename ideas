THINGS LEFT TO DO
DONE - update delimiter to reflect npaths_delimiter
DONE - set up the base paths
DONE - set up the bfs
DONE - combine the two sides of path and update variables
DONE - update the farm to reflect paths that have touched that node
DONE - verify solution
DONE - realloc
DONE - delete path_info
DONE - delete pathsets
		delete_bfs - same as delete paths i think
done - make solution printable
done - test
Done - norm
done - test
done - notes
done - guide for how to solve
done - readme

done  - make a doubly linked list or work around a single one for the pathsets?

TO SAVE SPACE
- delete larger binary tree wrapper
- use singe bits instead of whole data type in structs

TO SAVE TIME
	- Try using other vairables aren't doubling everytime you need more memory
		1.5 MIGHT be more effiecent. Try it
	- Try using more write calls instead of more malloc calls?
	- for input, try different initial allocations. Maybe the difference between using the size of a line
		vs some larger number just for less allocations
	- make individual variables for things that are hard to access
	- dfs?

1 - should i create a binary tree of the rooms as i receive them
		pros:
			validation would be made quicker and easier
		cons:
			might not need to be validated which means it could be a waste of
			space and/or time

2 - how to store the paths that are created. must be efficient

still need to make the queue to store each successive room. there are
going to be a lot of data structures in this, maybe try to limit that for
time? or would it be fine to use a lot and it would be faster because of the
structures choosen



int		i;
int		room;
int		#ofrooms;

#ofrooms = 8;
firsthalf = #ofrooms / 2;
room = 0;
i = 0;
while (i < #ofrooms)
{
	//first look through the rooms by column
	m[column][room];
	++i;
}
while (i < #ofrooms)
{
	//then (for the second half) look through the room by row
	m[room][row];
	++i;
}


equations for adding a new path

ants - total ants going through path
moves - lines on the stdout
paths - there can be multiple sets of working paths, so paths is only
		considering the set that is being looked at
pathlen - longest path length (in links) of the current path set
canlook - can you check the routes for another ending (one itteration)

equation for how many moves it would take in the current configuration:

moves = ants/paths


moves = ((ants + pathlen) - 1) + 

equation for how many ants should go on the new path:
is it always better to send an ant down a shorter path?


//canlook = if ((#ants / #paths) > pathlen)

TRUE
if (pathlen of new longest < #moves)
	add it

should pathlen be in links and not rooms? probably because that is also the amount of moves

4 / 2 + 4 % 2 + 5 = 7 (6)
4 / 1 + 4 % 1 + 4 = 8 (7)

5 / 2 + 5 % 2 + 5 = 8 (6)
5 / 1 + 5 % 1 + 4 = 9 (8)

6 / 2 + 6 % 2 + 5 = 8 (6)
6 / 1 + 6 % 1 + 4 = 9 (8)
