Questions

TO SAVE SPACE
- delete larger binary tree wrapper
- use singe bits instead of whole data type in structs


TO SAVE TIME
	- Try using other vairables aren't doubling everytime you need more memory
		1.5 MIGHT be more effiecent. Try it
	- Try using more write calls instead of more malloc calls?
	- for input, try different initial allocations. Maybe the difference between using the size of a line
		vs some larger number just for less allocations

1 - should i create a binary tree of the rooms as i receive them
		pros:
			validation would be made quicker and easier
		cons:
			might not need to be validated which means it could be a waste of
			space and/or time

2 - how to store the paths that are created. must be efficient

still need to make the queue to store each successive room. there are
going to be a lot of data structures in this, maybe try to limit that for
time? or would it be fine to use a lot and it would be faster because of the
structures choosen



int		i;
int		room;
int		#ofrooms;

#ofrooms = 8;
firsthalf = #ofrooms / 2;
room = 0;
i = 0;
while (i < #ofrooms)
{
	//first look through the rooms by column
	m[column][room];
	++i;
}
while (i < #ofrooms)
{
	//then (for the second half) look through the room by row
	m[room][row];
	++i;
}


equations for adding a new path

ants - total ants going through path
moves - lines on the stdout
paths - there can be multiple sets of working paths, so paths is only
		considering the set that is being looked at
pathlen - longest path length (in links) of the current path set
canlook - can you check the routes for another ending (one itteration)

equation for how many moves it would take in the current configuration:

moves = ants/paths


moves = ((ants + pathlen) - 1) + 

equation for how many ants should go on the new path:
is it always better to send an ant down a shorter path?


//canlook = if ((#ants / #paths) > pathlen)

if (pathlen of new longest < #moves)
	add it

should pathlen be in links and not rooms? probably because that is also the amount of moves

4 / 2 + 4 % 2 + 5 = 7 (6)
4 / 1 + 4 % 1 + 4 = 8 (7)

5 / 2 + 5 % 2 + 5 = 8 (6)
5 / 1 + 5 % 1 + 4 = 9 (8)

6 / 2 + 6 % 2 + 5 = 8 (6)
6 / 1 + 6 % 1 + 4 = 9 (8)
